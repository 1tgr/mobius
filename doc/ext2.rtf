{\rtf1\ansi\ansicpg1252\deff0\deflang1024{\fonttbl{\f0\fnil\fcharset0 Times New Roman;}{\f1\fnil\fcharset0 Arial;}{\f2\fnil\fcharset0 Courier New;}}
{\stylesheet{ Normal;}{\s1 heading 1;}{\s2 heading 2;}{\s3 heading 3;}{\s4 heading 4;}{\s5 heading 5;}}
\viewkind4\uc1\pard\hyphpar0\sl20\slmult0\f0\fs20 $Id: ext2.rtf,v 1.2 2002/05/19 22:00:14 pavlovskii Exp $\par
\pard\keepn\hyphpar0\s1\sb373\sl647\slmult0\qc\b\f1\fs49 The Second Extended File System\par
\pard\keepn\hyphpar0\sb311\sl539\slmult0\qc\fs41 Internal Layout\par
\pard\hyphpar0\sl260\slmult0\b0\f0\fs20  \par
\pard\keepn\hyphpar0\sb796\sl449\slmult0\qc\b\f1\fs34 Dave Poirier\par
\pard\sb200\sl260\slmult0\qc\fs24       instinc@users.sf.net\par
\pard\hyphpar0\sl260\slmult0\qc      \par
\pard\hyphpar0\sb200\sl260\slmult0\qc Andreas Gruenbacher\par
\pard\hyphpar0\sl260\slmult0\qc Daniel Phillips\par
\page\pard\hyphpar0\sl20\slmult0\b0\f0\fs20\par
\pard\hyphpar0\sl-240\slmult0\b\f1 The Second Extended File System: Internal Layout\par
\pard\hyphpar0\sl260\slmult0\b0\f0 by Dave Poirier\par
Andreas Gruenbacher\par
Daniel Phillips\par
\pard\hyphpar0\sb260\sl260\slmult0 Copyright \'a9 2001-2002 by Dave Poirier\par
\pard\hyphpar0\sb200\sl260\slmult0\fs16 Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.1 or any later version published by the Free Software Foundation; with no Invariant Sections, with no Front-Cover Texts, and with no Back-Cover Texts. A copy of the license can be acquired electronically from http://www.fsf.org/licenses/fdl.html or by writing to 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\par
\pard\keepn\hyphpar0\s1\sb311\sl539\slmult0\b\f1\fs41 Table of Contents\par
\pard\keepn\hyphpar0\fi-480\li1440\sb83\sl260\slmult0\tqr\tldot\tx9360\f0\fs20 About this book\tab 000\par
\pard\keepn\hyphpar0\fi-480\li1440\sb48\sl260\slmult0\tqr\tldot\tx9360 1. Disk Organisation\tab 000\par
\pard\hyphpar0\fi-480\li1920\sb48\sl260\slmult0\tqr\tldot\tx9360\b0 1.1. superblock\tab 000\par
\pard\hyphpar0\fi-480\li2400\sl260\slmult0\tqr\tldot\tx9360 1.1.1. s_inodes_count\tab 000\par
1.1.2. s_blocks_count\tab 000\par
1.1.3. s_r_blocks_count\tab 000\par
1.1.4. s_free_blocks_count\tab 000\par
1.1.5. s_free_inodes_count\tab 000\par
1.1.6. s_first_data_block\tab 000\par
1.1.7. s_log_block_size\tab 000\par
1.1.8. s_log_frag_size\tab 000\par
1.1.9. s_blocks_per_group\tab 000\par
1.1.10. s_frags_per_group\tab 000\par
1.1.11. s_inodes_per_group\tab 000\par
1.1.12. s_mtime\tab 000\par
1.1.13. s_wtime\tab 000\par
1.1.14. s_mnt_count\tab 000\par
1.1.15. s_max_mnt_count\tab 000\par
1.1.16. s_magic\tab 000\par
1.1.17. s_state\tab 000\par
1.1.18. s_errors\tab 000\par
1.1.19. s_minor_rev_level\tab 000\par
1.1.20. s_lastcheck\tab 000\par
1.1.21. s_checkinterval\tab 000\par
1.1.22. s_creator_os\tab 000\par
1.1.23. s_rev_level\tab 000\par
1.1.24. s_def_resuid\tab 000\par
1.1.25. s_def_resgid\tab 000\par
1.1.26. s_first_ino\tab 000\par
1.1.27. s_inode_size\tab 000\par
1.1.28. s_block_group_nr\tab 000\par
1.1.29. s_feature_compat\tab 000\par
1.1.30. s_feature_incompat\tab 000\par
1.1.31. s_feature_ro_compat\tab 000\par
1.1.32. s_uuid\tab 000\par
1.1.33. s_volume_name\tab 000\par
1.1.34. s_last_mounted\tab 000\par
1.1.35. s_algo_bitmap\tab 000\par
\pard\hyphpar0\fi-480\li1920\sl260\slmult0\tqr\tldot\tx9360 1.2. Group Descriptor\tab 000\par
\pard\hyphpar0\fi-480\li2400\sl260\slmult0\tqr\tldot\tx9360 1.2.1. bg_block_bitmap\tab 000\par
1.2.2. bg_inode_bitmap\tab 000\par
1.2.3. bg_inode_table\tab 000\par
1.2.4. bg_free_blocks_count\tab 000\par
1.2.5. bg_free_inodes_count\tab 000\par
1.2.6. bg_used_dirs_count\tab 000\par
1.2.7. bg_pad\tab 000\par
1.2.8. bg_reserved\tab 000\par
\pard\hyphpar0\fi-480\li1920\sl260\slmult0\tqr\tldot\tx9360 1.3. Block Bitmap\tab 000\par
1.4. Inode Bitmap\tab 000\par
1.5. Inode Table\tab 000\par
\pard\hyphpar0\fi-480\li2400\sl260\slmult0\tqr\tldot\tx9360 1.5.1. i_mode\tab 000\par
1.5.2. i_uid\tab 000\par
1.5.3. i_size\tab 000\par
1.5.4. i_atime\tab 000\par
1.5.5. i_ctime\tab 000\par
1.5.6. i_mtime\tab 000\par
1.5.7. i_dtime\tab 000\par
1.5.8. i_gid\tab 000\par
1.5.9. i_links_count\tab 000\par
1.5.10. i_blocks\tab 000\par
1.5.11. i_flags\tab 000\par
1.5.12. i_osd1\tab 000\par
1.5.13. i_block\tab 000\par
1.5.14. i_generation\tab 000\par
1.5.15. i_file_acl\tab 000\par
1.5.16. i_dir_acl\tab 000\par
1.5.17. i_faddr\tab 000\par
1.5.18. i_osd2\tab 000\par
\pard\hyphpar0\fi-480\li1920\sl260\slmult0\tqr\tldot\tx9360 1.6. Data Blocks\tab 000\par
\pard\keepn\hyphpar0\fi-480\li1440\sb48\sl260\slmult0\tqr\tldot\tx9360\b 2. Directory Structure\tab 000\par
\pard\hyphpar0\fi-480\li1920\sb48\sl260\slmult0\tqr\tldot\tx9360\b0 2.1. Directory File Format\tab 000\par
\pard\hyphpar0\fi-480\li2400\sl260\slmult0\tqr\tldot\tx9360 2.1.1. inode\tab 000\par
2.1.2. rec_len\tab 000\par
2.1.3. name_len\tab 000\par
2.1.4. file_type\tab 000\par
2.1.5. name\tab 000\par
\pard\hyphpar0\fi-480\li1920\sl260\slmult0\tqr\tldot\tx9360 2.2. Sample Directory\tab 000\par
2.3. Indexed Directory Format\tab 000\par
\pard\hyphpar0\fi-480\li2400\sl260\slmult0\tqr\tldot\tx9360 2.3.1. Index Structure\tab 000\par
2.3.2. Lookup Algorithm\tab 000\par
2.3.3. Insert Algorithm\tab 000\par
2.3.4. Splitting\tab 000\par
2.3.5. Key Collisions\tab 000\par
2.3.6. Hash Function\tab 000\par
2.3.7. Performance\tab 000\par
\pard\keepn\hyphpar0\fi-480\li1440\sb48\sl260\slmult0\tqr\tldot\tx9360\b 3. Inodes, file identifiers\tab 000\par
\pard\hyphpar0\fi-480\li1920\sb48\sl260\slmult0\tqr\tldot\tx9360\b0 3.1. Inode Number\tab 000\par
\pard\hyphpar0\fi-480\li1920\sl260\slmult0\tqr\tldot\tx9360 3.2. Locating the Inode structure\tab 000\par
3.3. Locating the Inode Table\tab 000\par
\pard\keepn\hyphpar0\fi-480\li1440\sb48\sl260\slmult0\tqr\tldot\tx9360\b 4. File Attributes\tab 000\par
\pard\hyphpar0\fi-480\li1920\sb48\sl260\slmult0\tqr\tldot\tx9360\b0 4.1. Standard Attributes\tab 000\par
\pard\hyphpar0\fi-480\li2400\sl260\slmult0\tqr\tldot\tx9360 4.1.1. SUID, SGID and -rwxrwxrwx\tab 000\par
4.1.2. File Size\tab 000\par
4.1.3. Owner and Group\tab 000\par
\pard\hyphpar0\fi-480\li1920\sl260\slmult0\tqr\tldot\tx9360 4.2. Extended Attributes\tab 000\par
\pard\hyphpar0\fi-480\li2400\sl260\slmult0\tqr\tldot\tx9360 4.2.1. Attribute Block Header\tab 000\par
4.2.2. Attribute Entry Header\tab 000\par
\pard\hyphpar0\fi-480\li1920\sl260\slmult0\tqr\tldot\tx9360 4.3. Behaviour Control Flags\tab 000\par
\pard\hyphpar0\fi-480\li2400\sl260\slmult0\tqr\tldot\tx9360 4.3.1. EXT2_SECRM_FL - Secure Deletion\tab 000\par
4.3.2. EXT2_UNRM_FL - Record for Undelete\tab 000\par
4.3.3. EXT2_COMPR_FL - Compressed File\tab 000\par
4.3.4. EXT2_SYNC_FL - Synchronous Updates\tab 000\par
4.3.5. EXT2_IMMUTABLE_FL - Immutable File\tab 000\par
4.3.6. EXT2_APPEND_FL - Append Only\tab 000\par
4.3.7. EXT2_NODUMP_FL - Do No Dump/Delete\tab 000\par
4.3.8. EXT2_NOATIME_FL - Do Not Update .i_atime\tab 000\par
4.3.9. EXT2_DIRTY_FL - Dirty\tab 000\par
4.3.10. EXT2_COMPRBLK_FL - Compressed Blocks\tab 000\par
4.3.11. EXT2_NOCOMPR_FL - Access Raw Compressed Data\tab 000\par
4.3.12. EXT2_ECOMPR_FL - Compression Error\tab 000\par
4.3.13. EXT2_BTREE_FL - B-Tree Format Directory\tab 000\par
4.3.14. EXT2_INDEX_FL - Hash Indexed Directory\tab 000\par
4.3.15. EXT2_IMAGIC_FL -\tab 000\par
4.3.16. EXT2_JOURNAL_DATA_FL - Journal File Data\tab 000\par
4.3.17. EXT2_RESERVED_FL - Reserved\tab 000\par
\pard\hyphpar0\fi-480\li1440\sb48\sl260\slmult0\tqr\tldot\tx9360\b A. Credits\tab 000\par
\pard\keepn\hyphpar0\s1\sb311\sl539\slmult0\f1\fs41 List of Tables\par
\pard\hyphpar0\fi-480\li1440\sb83\sl260\slmult0\tqr\tldot\tx9360\b0\f0\fs20 1-1. EXT2_ERRORS values\tab 000\par
\pard\hyphpar0\fi-480\li1440\sl260\slmult0\tqr\tldot\tx9360 1-2. EXT2_OS values\tab 000\par
1-3. EXT2 revisions\tab 000\par
1-4. EXT2_S_I values\tab 000\par
2-1. EXT2_FT values\tab 000\par
\pard\keepn\hyphpar0\s1\sb311\sl539\slmult0 4-1. Behaviour Control Flags\tab 000\b\f1\fs41 List of Figures\par
\pard\hyphpar0\fi-480\li1440\sb83\sl260\slmult0\tqr\tldot\tx9360\b0\f0\fs20 1-1. floppy disk meta-data layout\tab 000\par
\pard\hyphpar0\fi-480\li1440\sl260\slmult0\tqr\tldot\tx9360 1-2. 20mb partition meta-data layout\tab 000\par
1-3. superblock structure\tab 000\par
1-4. group_desc structure\tab 000\par
1-5. inode structure\tab 000\par
1-6. inode osd2 structure: Hurd\tab 000\par
1-7. inode osd2 structure: Linux\tab 000\par
1-8. inode osd2 structure: Masix\tab 000\par
2-1. directory entry\tab 000\par
2-2. Sample Directory Data Layout\tab 000\par
2-3. Performance of Indexed Directories\tab 000\par
3-1. Sample inode computations\tab 000\par
4-1. ext2_xattr_header structure\tab 000\par
4-2. ext2_xattr_header structure\tab 000\par
\pard\keepn\hyphpar0\s1\sb311\sl539\slmult0\b\f1\fs41 About this book\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  This book is intended as an introduction and guide to the Second Extended File System, also known as Ext2. The reader should have a good understanding of the purpose of a file system as well as the associated vocabulary (file, directory, partition, etc). \par
 Trying to implement ext2 drivers isn't always an easy task, the most difficult issue is unfortunately the documentation available. It seems like most of the documentation on the net about the internal layout of Ext2 was written to complement the Linux sources rather than be a complete document by themselves. \par
 Hopefully this document will fix this problem, may it be of help to as many of you as possible. \par
 \i Unless otherwise stated, all values are stored in little endian byte order.\i0  \par
\pard\keepn\hyphpar0\s1\sb311\sl539\slmult0\lang1024\b\f1\fs41 Chapter 1. Disk Organisation\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The first aspect of using the Second Extended File System one has to grasp is that all the meta-data structures size are based on a \ldblquote block\rdblquote  size rather than a \ldblquote sector\rdblquote  size. This block size is variable depending on the size of the file system. On a floppy disk for example, it is 1KB (2 sectors), while on a 10GB partition, the block size is normally 4KB or 8KB (8 and 16 sectors respectively). \par
 Each block is further sub-divided into "fragments", but I have yet to see a file system which fragment size doesn't match block size. Although my guts tells me that there must be some folks out there using different sizes for fragments and blocks. \par
 Except for the superblock, all meta-data structures are resized to fit into blocks. This is something to remember when trying to mount any other file system than one on a floppy. The \ldblquote Inode Table Block\rdblquote  for example will contain more entries in a 4KB block than in a 1KB block, so one will have to take that into account when accessing this particular structure. \par
 The next major aspect is that the file system is split into \ldblquote block groups\rdblquote . While a floppy would contain only one block group holding all the blocks of the file system, a hard disk of 10GB could easily be split into 30 of such block groups; each holding a certain quantity of blocks. \par
 At the start of each block group are various meta-data structures detailing the location of the other, more informative, meta-data structures defining the current file system state. Here's the organisation of an ext2 file system on a floppy: \par
\pard\keepn\hyphpar0\li960\sb200\sl260\slmult0\lang1024\b Figure 1-1. floppy disk meta-data layout\par
\pard\li960\sb100\sl234\slmult0\b0\f2\fs18 offset   # of blocks description\par
\pard\li960\sl234\slmult0 -------- ----------- -----------\par
       0           1 boot record\par
         -- block group 0 --\par
(1024 bytes)       1 superblock\par
       2           1 group descriptors\par
       3           1 block bitmap\par
       4           1 inode bitmap\par
       5          23 inode table\par
      28        1412 data blocks\par
\pard\hyphpar0\li960\sl234\slmult0   \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  And here's the organisation of a 20MB ext2 file system: \par
\pard\keepn\hyphpar0\li960\sb200\sl260\slmult0\lang1024\b Figure 1-2. 20mb partition meta-data layout\par
\pard\li960\sb100\sl234\slmult0\b0\f2\fs18 offset   # of blocks description\par
\pard\li960\sl234\slmult0 -------- ----------- -----------\par
       0           1 boot record\par
         -- block group 0 --\par
(1024 bytes)       1 superblock\par
       2           1 group descriptors\par
       3           1 block bitmap\par
       4           1 inode bitmap\par
       5         214 inode table\par
     219        7974 data blocks\par
         -- block group 1 --\par
    8193           1 superblock backup\par
    8194           1 group descriptors backup\par
    8195           1 block bitmap\par
    8196           1 inode bitmap\par
    8197         214 inode table\par
    8408        7974 data blocks\par
         -- block group 2 --\par
   16385           1 block bitmap\par
   16386           1 inode bitmap\par
   16387         214 inode table\par
   16601        3879 data blocks\par
\pard\hyphpar0\li960\sl234\slmult0   \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  The layout on disk is very predictable as long as you know a few basic information; block size, blocks per group, inodes per group. This information is all located in, or can be computed from, the superblock structure. \par
 Without the superblock information, the disk is useless; therefore as soon as enough space is available, one or more superblock backups will be created on the disk. \par
 The block bitmap and inode bitmap are used to identify which blocks and which inode entries are free to use. The data blocks is where the various files will be stored. Note that a directory is also seen as a file under Ext2, we will go in more detail about that later on. \par
 \i While all ext2 implementations try to be compatible, some fields in the various structures have been customized to fit the requirements of a specific operating system. Where such differences are known, they will be indicated in proper time.\i0  \par
\pard\keepn\hyphpar0\s2\sb216\sl374\slmult0\lang1024\b\f1\fs28 1.1. superblock\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The superblock is the structure on an ext2 disk containing the very basic information about the file system properties. It is layed out in the following form: \par
\pard\keepn\hyphpar0\li960\sb200\sl260\slmult0\lang1024\b Figure 1-3. superblock structure\par
\pard\li960\sb100\sl234\slmult0\b0\f2\fs18 offset  size    description\par
\pard\li960\sl234\slmult0 ------- ------- -----------\par
      0       4 s_inodes_count\par
      4       4 s_blocks_count\par
      8       4 s_r_blocks_count\par
     12       4 s_free_blocks_count\par
     16       4 s_free_inodes_count\par
     20       4 s_first_data_block\par
     24       4 s_log_block_size\par
     28       4 s_log_frag_size\par
     32       4 s_blocks_per_group\par
     36       4 s_frags_per_group\par
     40       4 s_inodes_per_group\par
     44       4 s_mtime\par
     48       4 s_wtime\par
     52       2 s_mnt_count\par
     54       2 s_max_mnt_count\par
     56       2 s_magic\par
     58       2 s_state\par
     60       2 s_errors\par
     62       2 s_minor_rev_level\par
     64       4 s_lastcheck\par
     68       4 s_checkinterval\par
     72       4 s_creator_os\par
     76       4 s_rev_level\par
     80       2 s_def_resuid\par
     82       2 s_def_resgid\par
   -- EXT2_DYNAMIC_REV Specific --\par
     84       4 s_first_ino\par
     88       2 s_inode_size\par
     90       2 s_block_group_nr\par
     92       4 s_feature_compat\par
     96       4 s_feature_incompat\par
    100       4 s_feature_ro_compat\par
    104      16 s_uuid\par
    120      16 s_volume_name\par
    136      64 s_last_mounted\par
    200       4 s_algo_bitmap\par
   -- Performance Hints         --\par
    204       1 s_prealloc_blocks\par
    205       1 s_prealloc_dir_blocks\par
    206       2 - (alignment)\par
   -- Journaling Support        --\par
    208      16 s_journal_uuid\par
    224       4 s_journal_inum\par
    228       4 s_journal_dev\par
    232       4 s_last_orphan\par
   -- Unused                    --\par
    236     788 - (padding)\par
\pard\hyphpar0\li960\sl234\slmult0    \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\b\f1\fs24 1.1.1. s_inodes_count\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value indicating the total number of inodes, both used and free, in the file system. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.2. s_blocks_count\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value indicating the total number of blocks, both used and free, in the file system. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.3. s_r_blocks_count\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value indicating the total number of blocks reserved for the usage of the super user. This is most useful if for some reason a user, maliciously or not, fill the file system to capacity; the super user will have this specified amount of free blocks at his disposal so he can edit and save configuration files. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.4. s_free_blocks_count\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value indicating the total number of free blocks, including the number of reserved blocks (see s_r_blocks_count). This is a sum of all free blocks of all the block groups. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.5. s_free_inodes_count\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value indicating the total number of free inodes. This is a sum of all free inodes of all the block groups. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.6. s_first_data_block\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value identifying the first data block, in other word the id of the block containing the superblock structure. \par
 Note that this value is always 0 for file systems with a block size larger than 1KB, and always 1 for file systems with a block size of 1KB. The superblock is \i always\i0  starting at the 1024th byte of the disk, which normally happens to be the first byte of the 3rd sector. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.7. s_log_block_size\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The block size is computed using this 32bit value as the number of bits to shift left the value 1024. This value may only be positive. \par
\pard\li960\sb200\sl234\slmult0\lang1024\f2\fs18 block size = 1024 << s_log_block_size;\par
\pard\hyphpar0\li960\sl234\slmult0     \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\b\f1\fs24 1.1.8. s_log_frag_size\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The fragment size is computed using this 32bit value as the number of bits to shift left the value 1024. Note that a negative value would shift the bit right rather than left. \par
\pard\li960\sb200\sl234\slmult0\lang1024\f2\fs18 if( positive )\par
\pard\li960\sl234\slmult0   fragmnet size = 1024 << s_log_frag_size;\par
else\par
  framgnet size = 1024 >> -s_log_frag_size;\par
\pard\hyphpar0\li960\sl234\slmult0     \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\b\f1\fs24 1.1.9. s_blocks_per_group\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value indicating the total number of blocks per group. This value in combination with s_first_data_block can be used to determine the block groups boundaries. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.10. s_frags_per_group\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value indicating the total number of fragments per group. It is also used to determine the size of the block bitmap of each block group. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.11. s_inodes_per_group\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value indicating the total number of inodes per group. This is also used to determine the size of the inode bitmap of each block group. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.12. s_mtime\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Unix time, as defined by POSIX, of the last time the file system was mounted. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.13. s_wtime\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Unix time, as defined by POSIX, of the last write access to the file system. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.14. s_mnt_count\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value indicating how many time the file system was mounted since the last time it was fully verified. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.15. s_max_mnt_count\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value indicating the maximum number of times that the file system may be mounted before a full check is performed. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.16. s_magic\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit value identifying the file system as Ext2. The value is currently fixed to \f2\fs18 0xEF53\f0\fs20 . \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.17. s_state\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit value indicating the file system state. When the file system is mounted, this state is set to \f2\fs18 EXT2_ERROR_FS\f0\fs20 . When the file system is not yet mounted, this value may be either \f2\fs18 EXT2_VALID_FS\f0\fs20  or \f2\fs18 EXT2_ERROR_FS\f0\fs20  in the event the file system was not cleanly unmounted. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.18. s_errors\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit value indicating what the file system driver should do when an error is detected. The following values have been defined: \par
\pard\keepn\li960\sb200\sa100\sl260\slmult0\lang1024\b Table 1-1. EXT2_ERRORS values\par
\trowd\trleft100\cellx4740\cellx5580\cellx9360\pard\intbl\sl260\slmult0\b0 EXT2_ERRORS_CONTINUE\cell 1\cell continue as if nothing happened\cell\row
\intbl EXT2_ERRORS_RO\cell 2\cell remount read-only\cell\row
\intbl EXT2_ERRORS_PANIC\cell 3\cell cause a kernel panic\cell\row
\intbl EXT2_ERRORS_DEFAULT\cell varies\cell as of revision 0.5, this is the same as EXT2_ERRORS_CONTINUE\cell\row
\pard\hyphpar0\sl-1\slmult0\fs24\par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\b\f1 1.1.19. s_minor_rev_level\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit value identifying the minor revision level within its revision level. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.20. s_lastcheck\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Unix time, as defined by POSIX, of the last file system check. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.21. s_checkinterval\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Maximum Unix time interval, as defined by POSIX, allowed between file system checks. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.22. s_creator_os\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit identifier of the os that created the file system. Defined values are: \par
\pard\keepn\li960\sb200\sa100\sl260\slmult0\lang1024\b Table 1-2. EXT2_OS values\par
\trowd\trleft100\cellx4740\cellx5580\cellx9360\pard\intbl\sl260\slmult0\b0 EXT2_OS_LINUX\cell 0\cell Linux\cell\row
\intbl EXT2_OS_HURD\cell 1\cell Hurd\cell\row
\intbl EXT2_OS_MASIX\cell 2\cell MASIX\cell\row
\intbl EXT2_OS_FREEBSD\cell 3\cell FreeBSD\cell\row
\intbl EXT2_OS_LITES4\cell 4\cell Lites\cell\row
\pard\hyphpar0\sl-1\slmult0\fs24\par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\b\f1 1.1.23. s_rev_level\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit revision level value. There are currently only 2 values defined: \par
\pard\keepn\li960\sb200\sa100\sl260\slmult0\lang1024\b Table 1-3. EXT2 revisions\par
\trowd\trleft100\cellx4740\cellx5580\cellx9360\pard\intbl\sl260\slmult0\b0 EXT2_GOOD_OLD_REV\cell 0\cell original format\cell\row
\intbl EXT2_DYNAMIC_REV\cell 1\cell V2 format with dynamic inode sizes\cell\row
\pard\hyphpar0\sl-1\slmult0\fs24\par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\b\f1 1.1.24. s_def_resuid\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit value used as the default user id for reserved blocks. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.25. s_def_resgid\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit value used as the default group id for reserved blocks. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.26. s_first_ino\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value used as index to the first inode useable for standard files. In the non-dynamic file system revisions, the first non-reserved inode was fixed to \f2\fs18 11\f0\fs20 . With the introduction the dynamic revision of the file system it is now possible to modify this value. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.27. s_inode_size\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit value indicating the size of the inode structure. In non-dynamic file system revisions this value is assumed to be \f2\fs18 128\f0\fs20 . \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.28. s_block_group_nr\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit value used to indicate the block group number hosting this superblock structure. This can be used to rebuild the file system from any superblock backup. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.29. s_feature_compat\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit bitmask of compatible features. The file system implementation is free to support them or not without risk of damaging the meta-data. (more information will be added soon) \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.30. s_feature_incompat\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit bitmask of incompatible features. The file system implementation should refuse to mount the file system if any of the indicated feature is unsupported. (more information will be added soon) \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.31. s_feature_ro_compat\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit bitmask of \ldblquote read-only\rdblquote  features. The file system implementation should mount as read-only if any of the indicated feature is unsupported. (more information will be added soon) \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.32. s_uuid\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  128bit value used as the volume id. This should, as much as possible, be unique for each file system formatted. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.33. s_volume_name\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16 bytes volume name, mostly unusued. A valid volume name would consist of only ISO-Latin-1 characters and be 0 terminated. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.34. s_last_mounted\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  64 bytes directory path where the file system was last mounted. While not normally used, it could serve for auto-finding the mountpoint when not indicated on the command line. Again the path should be zero terminated for compatibility reasons. Valid path is constructed from ISO-Latin-1 characters. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.1.35. s_algo_bitmap\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value used by compression algorithms to determine the methods used. (I do not have any more detail about this field, if you do please do send me all the information you have, thanks). \par
\pard\keepn\hyphpar0\s2\sb216\sl374\slmult0\lang1024\b\f1\fs28 1.2. Group Descriptor\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Located on the first block following the superblock, is a sequence of all the group descriptors required to describe the entire disk subdivisions. Each group descriptor describe a \ldblquote block group\rdblquote , giving the location of its inode table, block and inode bitmaps, etc. Here's what one of the group descriptor looks like: \par
\pard\keepn\hyphpar0\li960\sb200\sl260\slmult0\lang1024\b Figure 1-4. group_desc structure\par
\pard\li960\sb100\sl234\slmult0\b0\f2\fs18 offset  size    description\par
\pard\li960\sl234\slmult0 ------- ------- -----------\par
      0       4 bg_block_bitmap\par
      4       4 bg_inode_bitmap\par
      8       4 bg_inode_table\par
     12       2 bg_free_blocks_count\par
     14       2 bg_free_inodes_count\par
     16       2 bg_used_dirs_count\par
     18       2 bg_pad\par
     20      12 bg_reserved\par
\pard\hyphpar0\li960\sl234\slmult0    \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  For each group in the file system, such a group_desc is created. Each represent a single \ldblquote block group\rdblquote  within the file system and the information within any one of them is pertinent only to the group it is describing. Every \ldblquote Group Descriptor Table\rdblquote  contains all the information about all the groups. \par
 All indicated \ldblquote block id\rdblquote  are absolute. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.2.1. bg_block_bitmap\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit block id of the first block of the \ldblquote block bitmap\rdblquote  for the group represented. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.2.2. bg_inode_bitmap\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit block id of the first block of the \ldblquote inode bitmap\rdblquote  for the group represented. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.2.3. bg_inode_table\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit block id of the first block of the \ldblquote inode table\rdblquote  for the group represented. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.2.4. bg_free_blocks_count\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit value indicating the total number of free blocks for the represented group. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.2.5. bg_free_inodes_count\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit value indicating the total number of free inodes for the represented group. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.2.6. bg_used_dirs_count\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit value indicating the number of inodes allocated to directories for the represented group. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.2.7. bg_pad\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit value used for padding the structure on a 32bit boundary. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.2.8. bg_reserved\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  3 successive 32bit values reserved for future implementations. \par
\pard\keepn\hyphpar0\s2\sb216\sl374\slmult0\lang1024\b\f1\fs28 1.3. Block Bitmap\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The \ldblquote Block Bitmap\rdblquote  is normally located at the first block, or second block if a superblock backup is present, of the block group. Its official location can be determined by reading the \ldblquote bg_block_bitmap\rdblquote  in its associated group descriptor. \par
 Each bit represent the current state of a block within that group, where 1 means \ldblquote free\rdblquote  and 0 \ldblquote used\rdblquote . The first block of this block group is represented by bit 0 of byte 0, the second by bit 1 of byte 0. The 8th block is represented by bit 7 (most significant bit) of byte 0 while the 9th block is represented by bit 0 (least significant bit) of byte 1. \par
\pard\keepn\hyphpar0\s2\sb216\sl374\slmult0\lang1024\b\f1\fs28 1.4. Inode Bitmap\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The \ldblquote Inode Bitmap\rdblquote  works in a similar way as the \ldblquote Block Bitmap\rdblquote , difference being in each bit representing an inode in the \ldblquote Inode Table\rdblquote  rather than a block. \par
 There is one inode bitmap per group and its location may be determined by reading the \ldblquote bg_inode_bitmap\rdblquote  in its associated group descriptor. \par
\pard\keepn\hyphpar0\s2\sb216\sl374\slmult0\lang1024\b\f1\fs28 1.5. Inode Table\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The \ldblquote Inode Table\rdblquote  is used to keep track of every file; their location, size, type and access rights are all stored in inodes. The filename is not stored in there though, within the inode tables all files are refenced by their inode number. \par
 There is one inode table per group and it can be located by reading the \ldblquote bg_inode_table\rdblquote  in its associated group descriptor. There are s_inodes_per_group inodes per table. \par
 Each inode contain the information about a single physical file on the system. A file can be a directory, a socket, a buffer, character or block device, symbolic link or a regular file. So an inode can be seen as a block of information related to an entity, describing its location on disk, its size and its owner. An inode looks like this: \par
\pard\keepn\hyphpar0\li960\sb200\sl260\slmult0\lang1024\b Figure 1-5. inode structure\par
\pard\li960\sb100\sl234\slmult0\b0\f2\fs18 offset  size    description\par
\pard\li960\sl234\slmult0 ------- ------- -----------\par
      0       2 i_mode\par
      2       2 i_uid\par
      4       4 i_size\par
      8       4 i_atime\par
     12       4 i_ctime\par
     16       4 i_mtime\par
     20       4 i_dtime\par
     24       2 i_gid\par
     26       2 i_links_count\par
     28       4 i_blocks\par
     32       4 i_flags\par
     36       4 i_osd1\par
     40  15 x 4 i_block\par
    100       4 i_generation\par
    104       4 i_file_acl\par
    108       4 i_dir_acl\par
    112       4 i_faddr\par
    116      12 i_osd2\par
\pard\hyphpar0\li960\sl234\slmult0    \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\b\f1\fs24 1.5.1. i_mode\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit value used to indicate the format of the described file and the access rights. Here are the possible values, which can be combined in various ways: \par
\pard\keepn\li960\sb200\sa100\sl260\slmult0\lang1024\b Table 1-4. EXT2_S_I values\par
\trowd\trleft100\cellx9360\pard\intbl\sl260\slmult0\b0 -- file format --\cell\row
\trowd\trleft100\cellx4740\cellx5580\cellx9360\pard\intbl\sl260\slmult0 EXT2_S_IFMT\cell 0xF000\cell format mask\cell\row
\intbl EXT2_S_IFSOCK\cell 0xA000\cell socket\cell\row
\intbl EXT2_S_IFLNK\cell 0xC000\cell symbolic link\cell\row
\intbl EXT2_S_IFREG\cell 0x8000\cell regular file\cell\row
\intbl EXT2_S_IFBLK\cell 0x6000\cell block device\cell\row
\intbl EXT2_S_IFDIR\cell 0x4000\cell directory\cell\row
\intbl EXT2_S_IFCHR\cell 0x2000\cell character device\cell\row
\intbl EXT2_S_IFIFO\cell 0x1000\cell fifo\cell\row
\trowd\trleft100\cellx9360\pard\intbl\sl260\slmult0 -- access rights --\cell\row
\trowd\trleft100\cellx4740\cellx5580\cellx9360\pard\intbl\sl260\slmult0 EXT2_S_ISUID\cell 0x0800\cell SUID\cell\row
\intbl EXT2_S_ISGID\cell 0x0400\cell SGID\cell\row
\intbl EXT2_S_ISVTX\cell 0x0200\cell sticky bit\cell\row
\intbl EXT2_S_IRWXU\cell 0x01C0\cell user access rights mask\cell\row
\intbl EXT2_S_IRUSR\cell 0x0100\cell read\cell\row
\intbl EXT2_S_IWUSR\cell 0x0080\cell write\cell\row
\intbl EXT2_S_IXUSR\cell 0x0040\cell execute\cell\row
\intbl EXT2_S_IRWXG\cell 0x0038\cell group access rights mask\cell\row
\intbl EXT2_S_IRGRP\cell 0x0020\cell read\cell\row
\intbl EXT2_S_IWGRP\cell 0x0010\cell write\cell\row
\intbl EXT2_S_IXGRP\cell 0x0008\cell execute\cell\row
\intbl EXT2_S_IRWXO\cell 0x0007\cell others access rights mask\cell\row
\intbl EXT2_S_IROTH\cell 0x0004\cell read\cell\row
\intbl EXT2_S_IWOTH\cell 0x0002\cell write\cell\row
\intbl EXT2_S_IXOTH\cell 0x0001\cell execute\cell\row
\pard\hyphpar0\sl-1\slmult0\fs24\par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\b\f1 1.5.2. i_uid\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit user id associated with the file. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.3. i_size\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value indicating the size of the file in bytes. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.4. i_atime\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value representing the number of seconds since january 1st 1970 of the last time this file was accessed. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.5. i_ctime\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value representing the number of seconds since january 1st 1970 when the file was created. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.6. i_mtime\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value representing the number of seconds since january 1st 1970 of the last time this file was modified. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.7. i_dtime\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value representing the number of seconds since january 1st 1970 when the file was deleted. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.8. i_gid\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit value of the group having access to this file. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.9. i_links_count\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit value indicating how many times this particular inode is linked (referred to). \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.10. i_blocks\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value indicating the amount of blocks reserved for the associated file data. This includes both currently in used and currently reserved blocks in case the file grows in size. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.11. i_flags\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value indicating how the ext2 implementation should behave when accessing the data for this inode. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.12. i_osd1\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit OS dependant value. \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 1.5.12.1. Hurd\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0  32bit value labeled as \ldblquote translator\rdblquote . \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 1.5.12.2. Linux\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0  32bit value currently reserved. \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 1.5.12.3. Masix\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0  32bit value currently reserved. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.13. i_block\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Array used to locate the blocks the particular file is stored on. Each entry is a 32bit block number. The first 12 entries in this array are block numbers, which can be used to fetch the first 12 blocks associated with the file. \par
 The 13th entry is an indirect block number. Which means that at the specified data block, you will find an array of direct block numbers. \par
 The 14th entry is an bi-indirect block number. Which means that at the specified data block, you will find an array of indirect block number, which in turn contains an array of block numbers that can be accessed directly. \par
 The 15th entry is an tri-indirect block number. It is a block number which contains an array of bi-indirect block number, etc. \par
 Each indirect/bi-indirect/tri-indirect block array contains as many entries of 32bit block numbers as possible (to fill one entire block). \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.14. i_generation\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value used to indicate the file version (used by NFS). \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.15. i_file_acl\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value indicating the block number containing the extended attributes. In previous revisions this value was always 0. \par
 A general description of ACL for Digital UNIX can be found at this url for the moment: http://www.tru64unix.compaq.com/docs/base_doc/DOCUMENTATION/HTML/AA-Q0R2D-TET1_html/sec.c27.html \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.16. i_dir_acl\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value used to indicate the \ldblquote high size\rdblquote  of the file. In previous revisions this value was always 0. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.17. i_faddr\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit value indicating the location of the last file fragment. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 1.5.18. i_osd2\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  96bit OS dependant structure. \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 1.5.18.1. Hurd\par
\pard\keepn\hyphpar0\li960\sb200\sl260\slmult0\f0 Figure 1-6. inode osd2 structure: Hurd\par
\pard\li960\sb100\sl234\slmult0\b0\f2\fs18 offset  size    description\par
\pard\li960\sl234\slmult0 ------- ------- -----------\par
      0       1 h_i_frag\par
      1       1 h_i_fsize\par
      2       2 h_i_mode_high\par
      4       2 h_i_uid_high\par
      6       2 h_i_gid_high\par
      8       4 h_i_author\par
\pard\hyphpar0\li960\sl234\slmult0      \par
\pard\keepn\hyphpar0\s5\li960\sb200\sl260\slmult0\i\f1\fs20 1.5.18.1.1. h_i_frag\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\i0\f0  8bit fragment number. \par
\pard\keepn\hyphpar0\s5\li960\sb200\sl260\slmult0\lang1024\i\f1 1.5.18.1.2. h_i_fsize\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\i0\f0  8bit fragment size. \par
\pard\keepn\hyphpar0\s5\li960\sb200\sl260\slmult0\lang1024\i\f1 1.5.18.1.3. h_i_mode_high\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\i0\f0  \par
\pard\keepn\hyphpar0\s5\li960\sb200\sl260\slmult0\lang1024\i\f1 1.5.18.1.4. h_i_uid_high\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\i0\f0  High 16bit of user id. \par
\pard\keepn\hyphpar0\s5\li960\sb200\sl260\slmult0\lang1024\i\f1 1.5.18.1.5. h_i_gid_high\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\i0\f0  High 16bit of group id. \par
\pard\keepn\hyphpar0\s5\li960\sb200\sl260\slmult0\lang1024\i\f1 1.5.18.1.6. h_i_author\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\i0\f0  \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 1.5.18.2. Linux\par
\pard\keepn\hyphpar0\li960\sb200\sl260\slmult0\f0 Figure 1-7. inode osd2 structure: Linux\par
\pard\li960\sb100\sl234\slmult0\b0\f2\fs18 offset  size    description\par
\pard\li960\sl234\slmult0 ------- ------- -----------\par
      0       1 l_i_frag\par
      1       1 l_i_fsize\par
      2       2 reserved\par
      4       2 l_i_uid_high\par
      6       2 l_i_gid_high\par
      8       4 reserved\par
\pard\hyphpar0\li960\sl234\slmult0      \par
\pard\keepn\hyphpar0\s5\li960\sb200\sl260\slmult0\i\f1\fs20 1.5.18.2.1. l_i_frag\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\i0\f0  8bit fragment number. \par
\pard\keepn\hyphpar0\s5\li960\sb200\sl260\slmult0\lang1024\i\f1 1.5.18.2.2. l_i_fsize\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\i0\f0  8bit fragment size. \par
\pard\keepn\hyphpar0\s5\li960\sb200\sl260\slmult0\lang1024\i\f1 1.5.18.2.3. l_i_uid_high\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\i0\f0  High 16bit of user id. \par
\pard\keepn\hyphpar0\s5\li960\sb200\sl260\slmult0\lang1024\i\f1 1.5.18.2.4. l_i_gid_high\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\i0\f0  High 16bit of group id. \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 1.5.18.3. Masix\par
\pard\keepn\hyphpar0\li960\sb200\sl260\slmult0\f0 Figure 1-8. inode osd2 structure: Masix\par
\pard\li960\sb100\sl234\slmult0\b0\f2\fs18 offset  size    description\par
\pard\li960\sl234\slmult0 ------- ------- -----------\par
      0       1 m_i_frag\par
      1       1 m_i_fsize\par
      2      10 reserved\par
\pard\hyphpar0\li960\sl234\slmult0      \par
\pard\keepn\hyphpar0\s5\li960\sb200\sl260\slmult0\i\f1\fs20 1.5.18.3.1. m_i_frag\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\i0\f0  8bit fragment number. \par
\pard\keepn\hyphpar0\s5\li960\sb200\sl260\slmult0\lang1024\i\f1 1.5.18.3.2. m_i_fsize\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\i0\f0  8bit fragment size. \par
\pard\keepn\hyphpar0\s2\sb216\sl374\slmult0\lang1024\b\f1\fs28 1.6. Data Blocks\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Data blocks are used to store the various files' content, including directory listing, extended attributes, symbolic links, etc. \par
\pard\keepn\hyphpar0\s1\sb311\sl539\slmult0\lang1024\b\f1\fs41 Chapter 2. Directory Structure\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Directories are stored as files and can be identified as such by looking up the \i\f2 ext2_inode.i_mode\i0\f0  file format bits for the \f2\fs18 EXT2_S_IFDIR\f0\fs20  value. \par
 The root directory is always the second entry of the inode table (\f2\fs18 EXT2_ROOT_INO\f0\fs20  is of value 2). Any subdirectory from there can be located by looking at the content of the root directory file. \par
\pard\keepn\hyphpar0\s2\sb216\sl374\slmult0\lang1024\b\f1\fs28 2.1. Directory File Format\par
\pard\keepn\hyphpar0\li960\sb200\sl260\slmult0\f0\fs20 Figure 2-1. directory entry\par
\pard\li960\sb100\sl234\slmult0\b0\f2\fs18 offset  size    description\par
\pard\li960\sl234\slmult0 ------- ------- -----------\par
      0       4 inode\par
      4       2 rec_len\par
      6       1 name_len\par
      7       1 file_type\par
      8     ... name\par
\pard\hyphpar0\li960\sl234\slmult0    \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  Earlier implementations of Ext2 used a 16bit \i\f2 name_len\i0\f0 , but since this value is stored in Intel (little-endian) byte order and most implementation restricted filenames to maximum 255 characters, allowing a byte to be recycled. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 2.1.1. inode\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  32bit inode number of the file entry. A value of 0 indicate that the entry is not used. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 2.1.2. rec_len\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  16bit unsigned displacement to the next directory entry from the start of the current directory entry. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 2.1.3. name_len\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  8bit unsigned value indicating how many characters are contained in the name. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 2.1.4. file_type\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  8bit unsigned value used to indicate file type. As noted, this value may be 0 in earlier implementations. Currently defined values are: \par
\pard\keepn\li960\sb200\sa100\sl260\slmult0\lang1024\b Table 2-1. EXT2_FT values\par
\trowd\trleft960\cellx4740\cellx5580\cellx9360\pard\intbl\sl-120\slmult0\b0 EXT2_FT_UNKNOWN\cell 0\cell\fs24  \cell\row
\fs20\trowd\trleft960\cellx4740\cellx5580\cellx9360\intbl EXT2_FT_REG_FILE\cell 1\cell\fs24  \cell\row
\fs20\trowd\trleft960\cellx4740\cellx5580\cellx9360\intbl EXT2_FT_DIR\cell 2\cell\fs24  \cell\row
\fs20\trowd\trleft960\cellx4740\cellx5580\cellx9360\intbl EXT2_FT_CHRDEV\cell 3\cell\fs24  \cell\row
\fs20\trowd\trleft960\cellx4740\cellx5580\cellx9360\intbl EXT2_FT_BLKDEV\cell 4\cell\fs24  \cell\row
\fs20\trowd\trleft960\cellx4740\cellx5580\cellx9360\intbl EXT2_FT_FIFO\cell 5\cell\fs24  \cell\row
\fs20\trowd\trleft960\cellx4740\cellx5580\cellx9360\intbl EXT2_FT_SOCK\cell 6\cell\fs24  \cell\row
\fs20\trowd\trleft960\cellx4740\cellx5580\cellx9360\intbl EXT2_FT_SYMLINK\cell 7\cell\fs24  \cell\row
\fs20\trowd\trleft960\cellx4740\cellx5580\cellx9360\intbl EXT2_FT_MAX\cell 8\cell\fs24  \cell\row
\pard\hyphpar0\sl-1\slmult0\par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\b\f1 2.1.5. name\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Name of the entry. The allowed character set is the ISO-Latin-1. \par
\pard\keepn\hyphpar0\s2\sb216\sl374\slmult0\lang1024\b\f1\fs28 2.2. Sample Directory\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Here's a sample of the home directory of one user on my system: \par
\pard\li960\sb200\sl234\slmult0\lang1024\f2\fs18 $ ls -1a /home/eks\par
\pard\li960\sl234\slmult0 .\par
..\par
.bash_profile\par
.bashrc\par
mbox\par
public_html\par
tmp\par
\pard\hyphpar0\li960\sl234\slmult0    \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  For which the following data representation can be found on the storage device: \par
\pard\keepn\hyphpar0\li960\sb200\sl260\slmult0\lang1024\b Figure 2-2. Sample Directory Data Layout\par
\pard\li960\sb100\sl234\slmult0\b0\f2\fs18 offset  size    description\par
\pard\li960\sl234\slmult0 ------- ------- -----------\par
      0       4 inode number (783362)\par
      4       2 record length (9)\par
      6       1 name length (1)\par
      7       1 file type (EXT2_FT_DIR)\par
      8       1 name (.)\par
\par
      9       4 inode number (1109761)\par
     13       2 record length (10)\par
     15       1 name length (2)\par
     16       1 file type (EXT2_FT_DIR)\par
     17       2 name (..)\par
\par
     19       4 inode number (783364)\par
     23       2 record length (21)\par
     25       1 name length (13)\par
     26       1 file type (EXT2_FT_REG_FILE)\par
     27      13 name (.bash_profile)\par
\par
     40       4 inode number (783363)\par
     44       2 record length (15)\par
     46       1 name length (7)\par
     47       1 file type (EXT2_FT_REG_FILE)\par
     48       7 name (.bashrc)\par
\par
     55       4 inode number (783377)\par
     59       2 record length (12)\par
     61       1 name length (4)\par
     62       1 file type (EXT2_FT_REG_FILE)\par
     63       4 name (mbox)\par
\par
     67       4 inode number (783545)\par
     71       2 record length (19)\par
     73       1 name length (11)\par
     74       1 file type (EXT2_FT_DIR)\par
     75      11 name (public_html)\par
\par
     86       4 inode number (669354)\par
     90       2 record length (11)\par
     92       1 name length (3)\par
     93       1 file type (EXT2_FT_DIR)\par
     94       3 name (tmp)\par
\par
     97       4 inode number (0)\par
     101      2 record length (3999)\par
     103      1 name length (0)\par
     104      1 file type (EXT2_FT_UNKNOWN)\par
     105      0 name ()\par
\pard\hyphpar0\li960\sl234\slmult0    \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  It should be noted that some implementation will pad directory entries to have better performances on the host processor, it is thus important to use the \i\f2 record length\i0\f0  and not the \i\f2 name length\i0\f0  to find the next record. \par
\pard\keepn\hyphpar0\s2\sb216\sl374\slmult0\lang1024\b\f1\fs28 2.3. Indexed Directory Format\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Using the standard linked list directory format can become very slow once the number of files starts growing. To improve performances in such a system, a hashed index was created, which allow to quickly locate the particular file searched. \par
 Bit EXT2_INDEX_FL in the behaviour control flags is set if the indexed directory format is used. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 2.3.1. Index Structure\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The root of the index tree is in the 0th block of the file. Space is reserved for a second level of the index tree in blocks 1 though 511 (for 4K filesystem blocks). Directory leaf blocks are appended starting at block 512, thus the tail of the directory file looks like a normal Ext2 directory and can be processed directly by ext2_readdir. For directories with less than about 90K files there is a hole running from block 1 to block 511, so an empty directory has just two blocks in it, though its size appears to be about 2 Meg in a directory listing. \par
 So a directory file looks like: \par
\pard\li960\sb200\sl234\slmult0\lang1024\f2\fs18 0: Root index block\par
\pard\li960\sl234\slmult0 1: Index block/0\par
2: Index block/0\par
...\par
511: Index block/0\par
512: Dirent block\par
513: Dirent block\par
...\par
\pard\hyphpar0\li960\sl234\slmult0     \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  Each index block consists of 512 index entries of the form: \par
\pard\li960\sb200\sl234\slmult0\lang1024\f2\fs18        hash, block\par
\pard\hyphpar0\li960\sl234\slmult0     \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  where hash is a 32 bit hash with a collision flag in its least significant bit, and block is the logical block number of an index of leaf block, depending on the tree level. \par
 The hash value of the 0th index entry isn't needed because it can always be obtained from the level about, so it is used to record the count of index entries in an index block. This gives a nice round branching factor of 512, the evenness being a nicety that mainly satisfies my need to seek regularity, rather than winning any real performance. (On the other hand, the largeness of the branching factor matters a great deal.) \par
 The root index block has the same format as the other index blocks, with its first 8 bytes reserved for a small header: \par
\pard\li960\sb200\sl234\slmult0\lang1024\f2\fs18 1 byte header length (default: 8)\par
\pard\li960\sl234\slmult0 1 byte index type (default: 0)\par
1 byte hash version (default:0)\par
1 byte tree depth (default: 1)\par
\pard\hyphpar0\li960\sl234\slmult0     \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  The treatment of the header differs slightly in the attached patch. In particular, only a single level of the index tree (the root) is implemented here. This turns out to be sufficient to handle more than 90,000 entries, so it is enough for today. When a second level is added to the tree, capacity will incease to somewhere around 50 million entries, and there is nothing preventing the use of n levels, should there ever be a reason. It's doubtfull that a third level will ever be required, but if it is, the design provides for it. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 2.3.2. Lookup Algorithm\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Lookup is straightforword: \par
\pard\li960\sb200\sl234\slmult0\lang1024\f2\fs18 - Compute a hash of the name\par
\pard\li960\sl234\slmult0 - Read the index root\par
- Use binary search (linear in the current code) to find the\par
  first index or leaf block that could contain the target hash\par
  (in tree order)\par
- Repeat the above until the lowest tree level is reached\par
- Read the leaf directory entry block and do a normal Ext2\par
  directory block search in it.\par
- If the name is found, return its directory entry and buffer\par
- Otherwise, if the collision bit of the next directory entry is\par
  set, continue searching in the successor block\par
\pard\hyphpar0\li960\sl234\slmult0     \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  Normally, two logical blocks of the file will need to be accessed, and one or two metadata index blocks. The effect of the metadata index blocks can largely be ignored in terms of disk access time since these blocks are unlikely to be evicted from cache. There is some small CPU cost that can be addressed by moving the whole directory into the page cache. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 2.3.3. Insert Algorithm\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Insertion of new entries into the directory is considerably more complex than lookup, due to the need to split leaf blocks when they become full, and to satisfy the conditions that allow hash key collisions to be handled reliably and efficiently. I'll just summarize here: \par
\pard\li960\sb200\sl234\slmult0\lang1024\f2\fs18 - Probe the index as for lookup\par
\pard\li960\sl234\slmult0 - If the target leaf block is full, split it and note the block\par
  that will receive the new entry\par
- Insert the new entry in the leaf block using the normal Ext2\par
  directory entry insertion code.\par
\pard\hyphpar0\li960\sl234\slmult0     \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  The details of splitting and hash collision handling are somewhat messy, but I will be happy to dwell on them at length if anyone is interested. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 2.3.4. Splitting\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  In brief, when a leaf node fills up and we want to put a new entry into it the leaf has to be split, and its share of the hash space has to be partitioned. The most straightforward way to do this is to sort the entrys by hash value and split somewhere in the middle of the sorted list. This operation is log(number_of_entries_in_leaf) and is not a great cost so long as an efficient sorter is used. I used Combsort for this, although Quicksort would have been just as good in this case since average case performance is more important than worst case. \par
 An alternative approach would be just to guess a median value for the hash key, and the partition could be done in linear time, but the resulting poorer partitioning of hash key space outweighs the small advantage of the linear partition algorithm. In any event, the number of entries needing sorting is bounded by the number that fit in a leaf. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 2.3.5. Key Collisions\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Some complexity is introduced by the need to handle sequences of hash key collisions. It is desireable to avoid splitting such sequences between blocks, so the split point of a block is adjusted with this in mind. But the possibility still remains that if the block fills up with identically-hashed entries, the sequence may still have to be split. This situation is flagged by placing a 1 in the low bit of the index entry that points at the sucessor block, which is naturally interpreted by the index probe as an intermediate value without any special coding. Thus, handling the collision problem imposes no real processing overhead, just come extra code and a slight reduction in the hash key space. The hash key space remains sufficient for any conceivable number of directory entries, up into the billions. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 2.3.6. Hash Function\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The exact properties of the hash function critically affect the performance of this indexing strategy, as I learned by trying a number of poor hash functions, at times intentionally. A poor hash function will result in many collisions or poor partitioning of the hash space. To illustrate why the latter is a problem, consider what happens when a block is split such that it covers just a few distinct hash values. The probability of later index entries hashing into the same, small hash space is very small. In practice, once a block is split, if its hash space is too small it tends to stay half full forever, an effect I observed in practice. \par
 After some experimentation I came up with a hash function that gives reasonably good dispersal of hash keys across the entire 31 bit key space. This improved the average fullness of leaf blocks considerably, getting much closer to the theoretical average of 3/4 full. \par
 But the current hash function is just a place holder, waiting for an better version based on some solid theory. I currently favor the idea of using crc32 as the default hash function, but I welcome suggestions. \par
 Inevitably, no matter how good a hash function I come up with, somebody will come up with a better one later. For this reason the design allows for additional hash functiones to be added, with backward compatibility. This is accomplished simply, by including a hash function number in the index root. If a new, improved hash function is added, all the previous versions remain available, and previously created indexes remain readable. \par
 Of course, the best strategy is to have a good hash function right from the beginning. The initial, quick hack has produced results that certainly have not been disappointing. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 2.3.7. Performance\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  OK, if you have read this far then this is no doubt the part you've been waiting for. In short, the performance improvement over normal Ext2 has been stunning. With very small directories performance is similar to standard Ext2, but as directory size increases standard Ext2 quickly blows up quadratically, while htree-enhanced Ext2 continues to scale linearly. \par
 Uli Luckas ran benchmarks for file creation in various sizes of directories ranging from 10,000 to 90,000 files. The results are pleasing: total file creation time stays very close to linear, versus quadratic increase with normal Ext2. \par
 Time to create: \par
\pard\keepn\hyphpar0\li960\sb200\sl260\slmult0\lang1024\b Figure 2-3. Performance of Indexed Directories\par
\pard\li960\sb100\sl234\slmult0\b0\f2\fs18          Indexed         Normal\par
\pard\li960\sl234\slmult0                 =======         ======\par
10000 Files:    0m1.350s        0m23.670s\par
20000 Files:    0m2.720s        1m20.470s\par
30000 Files:    0m4.330s        3m9.320s\par
40000 Files:    0m5.890s        5m48.750s\par
50000 Files:    0m7.040s        9m31.270s\par
60000 Files:    0m8.610s        13m52.250s\par
70000 Files:    0m9.980s        19m24.070s\par
80000 Files:    0m12.060s       25m36.730s\par
90000 Files:    0m13.400s       33m18.550s\par
\pard\hyphpar0\li960\sl234\slmult0     \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  A graph is posted at: http://www.innominate.org/~phillips/htree/performance.png \par
 All of these tests are CPU-bound, which may come as a surprise. The directories fit easily in cache, and the limiting factor in the case of standard Ext2 is the looking up of directory blocks in buffer cache, and the low level scan of directory entries. In the case of htree indexing there are a number of costs to be considered, all of them pretty well bounded. Notwithstanding, there are a few obvious optimizations to be done: \par
\pard\li960\sb200\sl234\slmult0\lang1024\f2\fs18 - Use binary search instead of linear search in the interior index\par
\pard\li960\sl234\slmult0   nodes.\par
\par
- If there is only one leaf block in a directory, bypass the index\par
  probe, go straight to the block.\par
\par
- Map the directory into the page cache instead of the buffer cache.\par
\pard\hyphpar0\li960\sl234\slmult0     \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  Each of these optimizations will produce a noticeable improvement in performance, but naturally it will never be anything like the big jump going from N**2 to Log512(N), ~= N. In time the optimizations will be applied and we can expect to see another doubling or so in performance. \par
 There will be a very slight performance hit when the directory gets big enough to need a second level. Because of caching this will be very small. Traversing the directories metadata index blocks will be a bigger cost, and once again, this cost can be reduced by moving the directory blocks into the page cache. \par
 Typically, we will traverse 3 blocks to read or write a directory entry, and that number increases to 4-5 with really huge directories. But this is really nothing compared to normal Ext2, which traverses several hundred blocks in the same situation. \par
\pard\keepn\hyphpar0\s1\sb311\sl539\slmult0\lang1024\b\f1\fs41 Chapter 3. Inodes, file identifiers\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Every file, directory, symlink, special device, or anything else really stored in a ext2 file system, is identified by an inode. If you know the inode number of the file you want to read, even if you don't know the path to the file or even the file name, you can still locate the file on disk and read it. \par
\pard\keepn\hyphpar0\s2\sb216\sl374\slmult0\lang1024\b\f1\fs28 3.1. Inode Number\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The \ldblquote inode number\rdblquote  is an index in the inode table to an inode structure. The size of the inode table is fixed at format time, it is built to hold a maximum number of entries. Due to the normally sufficiently large amount of entries reserved, the table is quite big and thus, it was split equally among all the \ldblquote block groups\rdblquote  (see Chapter 1 for more information). \par
\pard\keepn\hyphpar0\s2\sb216\sl374\slmult0\lang1024\b\f1\fs28 3.2. Locating the Inode structure\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The s_inodes_per_group field in the superblock structure tells us how many inodes are defined per group. Knowing that inode 1 is the first inode defined in the inode table, one can use the following formulaes: \par
\pard\li960\sb200\sl234\slmult0\lang1024\f2\fs18 group = (inode - 1) / s_inodes_per_group\par
\pard\hyphpar0\li960\sl234\slmult0    \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  to locate which blocks group holds the part of the inode table containing the searched inode entry, and: \par
\pard\li960\sb200\sl234\slmult0\lang1024\f2\fs18 index = (inode - 1) % s_inodes_per_group\par
\pard\hyphpar0\li960\sl234\slmult0    \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  to get the index within this partial inode table to the searched inode entry. Here are a couple of sample values that could be used to test your implementation: \par
\pard\keepn\hyphpar0\li960\sb200\sl260\slmult0\lang1024\b Figure 3-1. Sample inode computations\par
\pard\li960\sb100\sl234\slmult0\b0\f2\fs18 s_inodes_per_group = 1712\par
\pard\li960\sl234\slmult0\par
inode number computation\par
------------ -----------\par
       1     group = (1 - 1) / 1712 = 0\par
             index = (1 - 1) % 1712 = 0\par
\par
       2     group = (2 - 1) / 1712 = 0\par
             index = (2 - 1) % 1712 = 1\par
\par
     963     group = (963 - 1) / 1712 = 0\par
             index = (963 - 1) % 1712 = 962\par
\par
    1712     group = (1712 - 1) / 1712 = 0\par
             index = (1712 - 1) % 1712 = 1711\par
\par
    1713     group = (1713 - 1) / 1712 = 1\par
             index = (1713 - 1) % 1712 = 0\par
\par
    3424     group = (3424 - 1) / 1712 = 1\par
             index = (3424 - 1) % 1712 = 1711\par
\par
    3425     group = (3425 - 1) / 1712 = 2\par
             index = (3425 - 1) % 1712 = 0\par
\pard\hyphpar0\li960\sl234\slmult0    \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  As many of you are most likely already familiar with, an index of 0 means the first entry. The reason behind using 0 rather than 1 is that it can more easily be multiplied by the structure size to find the final offset of its location in memory or on disk. \par
\pard\keepn\hyphpar0\s2\sb216\sl374\slmult0\lang1024\b\f1\fs28 3.3. Locating the Inode Table\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  As introduced in Section 3.1, the inode table is split equally among all group. If a file system was created to allow a thousand inodes, split between 5 groups, there would be 200 inodes per partial inode table. Figure 3-1 illustrates such similar distribution. \par
 Each partial inode table can be located using the bg_inode_table field of the group_descriptor structure of its associated blocks group. \par
\pard\keepn\hyphpar0\s1\sb311\sl539\slmult0\lang1024\b\f1\fs41 Chapter 4. File Attributes\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Most of the file (also directory, symlink, device...) attributes are located in the inode associated with the file. Some other attributes are only available as extended attributes. \par
\pard\keepn\hyphpar0\s2\sb216\sl374\slmult0\lang1024\b\f1\fs28 4.1. Standard Attributes\par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\fs24 4.1.1. SUID, SGID and -rwxrwxrwx\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  There isn't much to say about those, they are located with the SGID and SUID bits in ext2_inode.i_mode. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.1.2. File Size\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The size of a file can be determined by looking at the ext2_inode.i_size field. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.1.3. Owner and Group\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Under most implementations, the owner and group are 16bit values, but on some recent Linux and Hurd implementations the owner and group id are 32bit. When 16bit values are used, only the \ldblquote low\rdblquote  part should be used as valid, while when using 32bit value, both the \ldblquote low\rdblquote  and \ldblquote high\rdblquote  part should be used, the high part being shifted left 16 places then added to the low part. \par
 The low part of owner and group are located in ext2_inode.i_uid and ext2_inode.i_gid respectively. \par
 The high part of owner and group are located in ext2_inode.osd2.hurd.h_i_uid_high and ext2_inode.osd2.hurd.h_i_gid_high, respectively, for Hurd and located in ext2_inode.osd2.linux.l_i_uid_high and ext2_inode.osd2.linux.l_i_gid_high, respectively, for Linux. \par
\pard\keepn\hyphpar0\s2\sb216\sl374\slmult0\lang1024\b\f1\fs28 4.2. Extended Attributes\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Extended attributes are name:value pairs associated permanently with files and directories, similar to the environment strings associated with a process. An attribute may be defined or undefined. If it is defined, its value may be empty or non-empty. \par
 Extended attributes are extensions to the normal attributes which are associated with all inodes in the system. They are often used to provide additional functionality to a filesystem - for example, additional security features such as Access Control Lists (ACLs) may be implemented using extended attributes. \par
 Extended attributes are accessed as atomic objects. Reading retrieves the whole value of an attribute and stores it in a buffer. Writing replaces any previous value with the new value. \par
 In each ext2 inode, we have the i_file_acl field, reserved for Access Control Lists. This field is used for storing the block number on which the extended attributes of an inode are stored instead (ACLs are stored as extended attributes). \par
 Extended attributes are stored on `plain' disk blocks, which are not part of any files. The disk block layout is similar to the layout used for directories. After the attribute block header, entry headers follow. The size of entry headers varies with the length of the attribute name. \par
 The attribute values are on the same block as their attribute entry descriptions, aligned to the end of the attribute block. This allows for additional attributes to be added more easily. \par
 A list of attribute names associated with a file can be retrieved. The filesystem handler returns a string of names separated by null characters, terminated by two null characters at the end of the list. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.2.1. Attribute Block Header\par
\pard\keepn\hyphpar0\li960\sb200\sl260\slmult0\f0\fs20 Figure 4-1. ext2_xattr_header structure\par
\pard\li960\sb100\sl234\slmult0\b0\f2\fs18 offset  size    description\par
\pard\li960\sl234\slmult0 ------- ------- -----------\par
      0       4 h_magic\par
      4       4 h_refcount\par
      8       4 h_blocks\par
     12       4 h_hash\par
     16      16 reserved\par
\pard\hyphpar0\li960\sl234\slmult0     \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\b\f1\fs20 4.2.1.1. h_magic\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0  32bit magic number of identification (EXT2_XATTR_MAGIC = 0xEA020000). \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 4.2.1.2. h_refcount\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0  32bit value used as reference count. This value is incremented everytime a link is created to this attribute block and decremented when a link is destroyed. Whenever this value reaches 0 the attribute block can be freed. \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 4.2.1.3. h_blocks\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0  32bit value indicating how many blocks are currently used by the extended attributes. \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 4.2.1.4. h_hash\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0  32bit hash value of all attributes. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.2.2. Attribute Entry Header\par
\pard\keepn\hyphpar0\li960\sb200\sl260\slmult0\f0\fs20 Figure 4-2. ext2_xattr_header structure\par
\pard\li960\sb100\sl234\slmult0\b0\f2\fs18 offset  size    description\par
\pard\li960\sl234\slmult0 ------- ------- -----------\par
      0       1 e_name_len\par
      1       1 e_name_index\par
      2       2 e_value_offs\par
      4       4 e_value_block\par
      8       4 e_value_size\par
     12       4 e_hash\par
     16     ... e_name\par
\pard\hyphpar0\li960\sl234\slmult0     \par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\f0\fs20  The total size of an attribute entry is always rounded to the next 4-bytes boundary. \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 4.2.2.1. e_name_len\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0  8bit unsigned value indicating the length of the name. \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 4.2.2.2. e_name_index\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0  8bit unsigned value used as attribute name index. \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 4.2.2.3. e_value_offs\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0  16bit unsigned offset to the value within the value block. \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 4.2.2.4. e_value_block\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0  32bit id of the block holding the value. \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 4.2.2.5. e_value_size\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0  32bit unsigned value indicating the size of the attribute value. \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 4.2.2.6. e_hash\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0  32bit hash of attribute name and value. \par
\pard\keepn\hyphpar0\s4\li960\sb200\sl260\slmult0\lang1024\b\f1 4.2.2.7. e_name\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0  Attribute name. \par
\pard\keepn\hyphpar0\s2\sb216\sl374\slmult0\lang1024\b\f1\fs28 4.3. Behaviour Control Flags\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The i_flags value in the inode structure allows to specify how the file system should behave in regard to the file. The following bits are currently defined: \par
\pard\keepn\li960\sb200\sa100\sl260\slmult0\lang1024\b Table 4-1. Behaviour Control Flags\par
\trowd\trleft100\cellx4740\cellx5580\cellx9360\pard\intbl\sl260\slmult0\b0 EXT2_SECRM_FL\fs24\cell\fs20 0x00000001\cell secure deletion\cell\row
\intbl EXT2_UNRM_FL\fs24\cell\fs20 0x00000002\cell record for undelete\cell\row
\intbl EXT2_COMPR_FL\fs24\cell\fs20 0x00000004\cell compressed file\cell\row
\intbl EXT2_SYNC_FL\fs24\cell\fs20 0x00000008\cell synchronous updates\cell\row
\intbl EXT2_IMMUTABLE_FL\fs24\cell\fs20 0x00000010\cell immutable file\cell\row
\intbl EXT2_APPEND_FL\fs24\cell\fs20 0x00000020\cell append only\cell\row
\intbl EXT2_NODUMP_FL\fs24\cell\fs20 0x00000040\cell do not dump/delete file\cell\row
\intbl EXT2_NOATIME_FL\fs24\cell\fs20 0x00000080\cell do not update .i_atime\cell\row
\intbl EXT2_DIRTY_FL\fs24\cell\fs20 0x00000100\cell dirty (file is in use?)\cell\row
\intbl EXT2_COMPRBLK_FL\fs24\cell\fs20 0x00000200\cell compressed blocks\cell\row
\intbl EXT2_NOCOMPR_FL\fs24\cell\fs20 0x00000400\cell access raw compressed data\cell\row
\intbl EXT2_ECOMPR_FL\fs24\cell\fs20 0x00000800\cell compression error\cell\row
\intbl EXT2_BTREE_FL\fs24\cell\fs20 0x00010000\cell b-tree format directory\cell\row
\intbl EXT2_INDEX_FL\fs24\cell\fs20 0x00010000\cell Hash indexed directory\cell\row
\intbl EXT2_IMAGIC_FL\fs24\cell\fs20 0x00020000\cell ?\cell\row
\intbl EXT3_JOURNAL_DATA_FL\fs24\cell\fs20 0x00040000\cell journal file data\cell\row
\intbl EXT2_RESERVED_FL\fs24\cell\fs20 0x80000000\cell reserved for ext2 implementation\cell\row
\pard\hyphpar0\sl-1\slmult0\fs24\par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\b\f1 4.3.1. EXT2_SECRM_FL - Secure Deletion\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Enabling this bit will cause random data to be written over the flie's content several time before the blocks are unlinked. Note that this is highly implementation dependant and as such, it should not be assumed to be 100% secure. Make sure to study the implementation notes before relying on this option. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.2. EXT2_UNRM_FL - Record for Undelete\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  When supported by the implementation, setting this bit will cause the deleted data to be moved to a temporary location, where the user can restore the original file without any risk of data lost. This is most useful when using ext2 on a desktop or workstation. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.3. EXT2_COMPR_FL - Compressed File\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The file's content is compressed. There is no note about the particular algorithm used other than maybe the s_algo_bitmap field of the superblock structure. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.4. EXT2_SYNC_FL - Synchronous Updates\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The file's content in memory will be constantly synchronized with the content on disk. This is mostly used for very sensitive boot files or encryption keys that you do not want to lose in case of a crash. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.5. EXT2_IMMUTABLE_FL - Immutable File\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The blocks associated with the file will not be exchanged. If for any reason a file system defragmentation is launched, such files will not be moved. Mostly used for stage2 and stage1.5 boot loaders. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.6. EXT2_APPEND_FL - Append Only\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Writing can only be used to append content at the end of the file and not modify the current content. Example of such use could be mailboxes, where anybody could send a message to a user but not modify any already present. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.7. EXT2_NODUMP_FL - Do No Dump/Delete\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  Setting this bit will protect the file from deletion. As long as this bit is set, even if the i_links_count is 0, the file will not be removed. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.8. EXT2_NOATIME_FL - Do Not Update .i_atime\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  The i_atime field of the inode structure will not be modified when the file is accessed if this bit is set. The only good use I can think of that are related to security. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.9. EXT2_DIRTY_FL - Dirty\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  I do not have information at this moment about the use of this bit. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.10. EXT2_COMPRBLK_FL - Compressed Blocks\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  This flag is set if one or more blocks are compressed. You can have more information about compression on ext2 at http://www.netspace.net.au/~reiter/e2compr/ Note that the project has not been updated since 1999. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.11. EXT2_NOCOMPR_FL - Access Raw Compressed Data\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  When this flag is set, the file system implementation will not uncompress the data before fowarding it to the application but will rather give it as is. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.12. EXT2_ECOMPR_FL - Compression Error\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  This flag is set if an error was detected when trying to uncompress the file. \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.13. EXT2_BTREE_FL - B-Tree Format Directory\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.14. EXT2_INDEX_FL - Hash Indexed Directory\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.15. EXT2_IMAGIC_FL -\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.16. EXT2_JOURNAL_DATA_FL - Journal File Data\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  \par
\pard\keepn\hyphpar0\s3\li960\sb200\sl312\slmult0\lang1024\b\f1\fs24 4.3.17. EXT2_RESERVED_FL - Reserved\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  \par
\pard\keepn\hyphpar0\s1\sb311\sl539\slmult0\lang1024\b\f1\fs41 Appendix A. Credits\par
\pard\hyphpar0\li960\sb400\sl260\slmult0\lang1033\b0\f0\fs20  I would like to personally thank everybody who contributed to this document, you are numerous and in many cases I haven't kept track of all of you. Be sure that if you are not in this list, it's a mistake and do not hesitate to contact me, it will be a pleasure to add your name to the list. \par
\pard\li960\sb200\sl234\slmult0\lang1024\f2\fs18 Andreas Gruenbacher (a.gruenbacher@bestbits.at)\par
\pard\li960\sl234\slmult0   Section 4.2\par
\par
Daniel Phillips (phillips@innominate.de)\par
  Section 2.3.1\par
  Section 2.3.2\par
  Section 2.3.3\par
  Section 2.3.4\par
  Section 2.3.5\par
  Section 2.3.6\par
  Section 2.3.7\par
\pard\hyphpar0\li960\sl234\slmult0   \par
}
 
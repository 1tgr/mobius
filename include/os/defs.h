/* $Id: defs.h,v 1.13 2002/12/18 23:54:44 pavlovskii Exp $ */
#ifndef __OS_DEFS_H
#define __OS_DEFS_H

#include <sys/types.h>

/*!
 *    \ingroup    libsys
 *    \defgroup    osdefs    MÃ¶bius Types and Definitions
 *    @{
 */

/*!    Path to the system boot directory (ramdisk) */
#define SYS_BOOT    L"/System/Boot"
/*!    Path to the system ports directory */
#define SYS_PORTS    L"/System/Ports"
/*!    Path to the system devices directory */
#define SYS_DEVICES    L"/System/Devices"

/*!    \brief    Maximum length of a path specification, in characters */
#ifndef WIN32
#define MAX_PATH    256
#endif

#ifndef PAGE_SIZE
/*!    \brief    Size of one page on the target architecture */
#define PAGE_SIZE    4096
#endif

#ifndef __KERNEL_MEMORY_H
/*!    \brief    Rounds an address down to a page boundary */
#define PAGE_ALIGN(addr)    ((addr) & -PAGE_SIZE)
/*!    \brief    Rounds an address up to a page boundary */
#define PAGE_ALIGN_UP(addr)    (((addr) + PAGE_SIZE - 1) & -PAGE_SIZE)
#endif

#ifndef __KERNEL_VMM_H
/*! \brief Allow access only from kernel mode */
#define VM_MEM_KERNEL           0x00000000
/*! \brief Allow access from user mode and kernel mode */
#define VM_MEM_USER             0x00000003
/*! \brief Mask for privilege level bits */
#define VM_MEM_PL_MASK          0x00000003
/*! \brief Allow memory to be read */
#define VM_MEM_READ		0x00000004
/*! \brief Allow memory to be written */
#define VM_MEM_WRITE		0x00000008
/*! \brief Zero memory before it is used */
#define VM_MEM_ZERO		0x00000010
/*! \brief Disable write caching on memory */
#define VM_MEM_CACHE_WT         0x00000020
/*! \brief Disable all caching on memory */
#define VM_MEM_CACHE_NONE       0x00000040
/*! \brief Reserve a region of address space (nodes only) */
#define VM_MEM_RESERVED         0x00000100
#endif

/* Flags for FsCreate() and FsOpen() */
/*! Allows a file to be read from */
#define FILE_READ               0x01
/*! Allows a file to be written to */
#define FILE_WRITE              0x02
#define FILE_FORCE_CREATE       0x04
#define FILE_FORCE_OPEN         0x08
#define FILE_CREATE_OPEN        (FILE_FORCE_CREATE | FILE_FORCE_OPEN)
#define FILE_IS_DIRECTORY       0x10

/* Values for seek origin */
#define FILE_SEEK_SET           0
#define FILE_SEEK_CUR           1
#define FILE_SEEK_END           2

#ifdef i386
typedef uint32_t FARPTR;

#define MK_FP(seg, off)    ((FARPTR) (((uint32_t) (seg) << 16) | (uint16_t) (off)))
#define FP_SEG(fp)        (((FARPTR) fp) >> 16)
#define FP_OFF(fp)        (((FARPTR) fp) & 0xffff)
#define FP_TO_LINEAR(seg, off) ((void*) ((((uint16_t) (seg)) << 4) + ((uint16_t) (off))))

#ifndef __CONTEXT_DEFINED
#define __CONTEXT_DEFINED
typedef struct pusha_t pusha_t;
struct pusha_t
{
    uint32_t edi, esi, ebp, esp, ebx, edx, ecx, eax;
};

/*! \brief The layout of the stack frame generated by the assembly-language 
 *    interrupt handler.
 *
 *    The isr_and_switch routine (in start.asm), along with the individual 
 *    interrupt handlers and the processor, build this structure on the stack
 *    before isr() is called.
 */
typedef struct context_t context_t;
struct context_t
{
    uint32_t kernel_esp;
    context_t *ctx_prev;
    pusha_t regs;
    uint32_t gs, fs, es, ds;
    uint32_t intr, error;
    uint32_t eip, cs, eflags, esp, ss;
};

typedef struct context_v86_t context_v86_t;
struct context_v86_t
{
    uint32_t kernel_esp;
    context_t *ctx_prev;
    pusha_t regs;
    uint32_t gs, fs, es, ds;
    uint32_t intr, error;
    uint32_t eip, cs, eflags, esp, ss;

    /* extra fields for V86 mode */
    uint32_t v86_es, v86_ds, v86_fs, v86_gs;
};
#endif

#endif

typedef struct module_info_t module_info_t;
struct module_info_t
{
    module_info_t *prev, *next;
    wchar_t name[256];
    addr_t base;
    size_t length;
};

typedef struct process_info_t process_info_t;
/*!    \brief    User-mode process information structure */
struct process_info_t
{
    unsigned id;
    addr_t base;
    handle_t std_in, std_out;
    wchar_t cwd[256];
    wchar_t cmdline[256];
    module_info_t *module_first, *module_last;
};

#ifdef exception_info
#undef exception_info
#endif

typedef struct thread_info_t thread_info_t;
/*!
 *    \brief    User-mode thead information structure
 *
 *    On the x86 the \p FS segment contains this structure.
 */
struct thread_info_t
{
    /*!
     *    \brief DS-relative pointer to this structure
     *
     *    Use this pointer to avoid FS-relative memory accesses
     */
    thread_info_t *info;
    /*!    \brief    ID of this thread */
    uint32_t id;
    /*!    \brief    Pointer to this process's information structure */
    process_info_t *process;
    /*! \brief    Result code from the last syscall */
    int status;
    /*! \brief    Parameter passed to \p ThrCreateThread */
    void *param;
    /*handle_t msgqueue_event;*/
    void (*exception_handler)(void);
    context_t exception_info;
};

typedef struct fileop_t fileop_t;
/*!
 *    \brief    Contains status information for user-mode asynchronous I/O 
 *    operations
 */
struct fileop_t
{
    /*!
     *    \brief    Result of the operation
     *    Only valid just after calling \p FsRead or \p FsWrite and after
     *    having called \p ThrWaitHandle.
     *
     *    Valid error codes are found in \p <errno.h>.
     */
    status_t result;
    /*!
     *    \brief    Handle of the event to be signalled upon I/O completion
     */
    handle_t event;
    /*!
     *    \brief    Number of bytes transferred after the operation completed
     */
    size_t bytes;
};

#define FILE_ATTR_READ_ONLY     0x01
#define FILE_ATTR_HIDDEN        0x02
#define FILE_ATTR_SYSTEM        0x04
#define FILE_ATTR_VOLUME_ID     0x08
#define FILE_ATTR_DIRECTORY     0x10
#define FILE_ATTR_ARCHIVE       0x20
#define FILE_ATTR_DEVICE        0x1000
#define FILE_ATTR_LINK          0x2000

/* Flags for FsQueryFile() */
/*! Tests for the file's presence; does not return any other information */
#define FILE_QUERY_NONE         0
#define FILE_QUERY_DIRENT       1
/*! Returns \p dirent_standard_t information for the file */
#define FILE_QUERY_STANDARD     2
/*! Returns \p dirent_device_t information for the device */
#define FILE_QUERY_DEVICE       3

typedef struct dirent_t dirent_t;
/*! \brief    Contains information on an entry in a directory */
struct dirent_t
{
    unsigned vnode;
    wchar_t name[256];
};

typedef struct dirent_standard_t dirent_standard_t;
struct dirent_standard_t
{
    uint64_t length;
    uint64_t attributes;
    wchar_t mimetype[64];
};

typedef struct dirent_device_t dirent_device_t;
struct dirent_device_t
{
    wchar_t description[256];
    uint32_t device_class;
};

#ifndef _WINUSER_
/* Resources */
#define RT_CURSOR           1
#define RT_BITMAP           2
#define RT_ICON             3
#define RT_MENU             4
#define RT_DIALOG           5
#define RT_STRING           6
#define RT_FONTDIR          7
#define RT_FONT             8
#define RT_ACCELERATOR      9
#define RT_RCDATA           10
#define RT_MESSAGETABLE     11
#endif

typedef struct sysinfo_t sysinfo_t;
/*! \brief    Information structure for \p SysGetInfo() */
struct sysinfo_t
{
    size_t page_size;
    size_t pages_total;
    size_t pages_free;
    size_t pages_physical;
    size_t pages_kernel;
};

typedef struct systimes_t systimes_t;
/*! \brief    Information structure for \p SysGetTimes() */
struct systimes_t
{
    unsigned quantum;
    unsigned uptime;
    unsigned current_cputime;
};

/* \brief Flags for \p SysShutdown */

#define SHUTDOWN_HALT       0
#define SHUTDOWN_REBOOT     1
#define SHUTDOWN_POWEROFF   2
#define SHUTDOWN_FLUSH      3

/* Special handle values */
#define HANDLE_NULL         0
#define HANDLE_PROCESS      1

/*! @} */

#endif

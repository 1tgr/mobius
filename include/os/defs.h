/* $Id: defs.h,v 1.1.1.1 2002/12/31 01:26:22 pavlovskii Exp $ */
#ifndef __OS_DEFS_H
#define __OS_DEFS_H

#include <sys/types.h>

/*!
 *  \addtogroup vmm Virtual memory manager
 *  @{
 */
#ifndef PAGE_SIZE
/*!    \brief    Size of one page on the target architecture */
#define PAGE_SIZE    4096
#endif

#ifndef __KERNEL_MEMORY_H
/*! \brief Rounds an address down to a page boundary */
#define PAGE_ALIGN(addr)    ((addr) & -PAGE_SIZE)
/*! \brief Rounds an address up to a page boundary */
#define PAGE_ALIGN_UP(addr)    (((addr) + PAGE_SIZE - 1) & -PAGE_SIZE)
#endif

#ifndef __KERNEL_VMM_H
/*! \brief Allow access only from kernel mode */
#define VM_MEM_KERNEL			0x00000000
/*! \brief Allow access from user mode and kernel mode */
#define VM_MEM_USER				0x00000003
/*! \brief Mask for privilege level bits */
#define VM_MEM_PL_MASK			0x00000003
/*! \brief Allow memory to be read */
#define VM_MEM_READ				0x00000004
/*! \brief Allow memory to be written */
#define VM_MEM_WRITE			0x00000008
/*! \brief Zero memory before it is used */
#define VM_MEM_ZERO				0x00000010
/*! \brief Disable write caching on memory */
#define VM_MEM_CACHE_WT			0x00000020
/*! \brief Disable all caching on memory */
#define VM_MEM_CACHE_NONE		0x00000040
/*! \brief Reserve a region of address space */
#define VM_MEM_RESERVED			0x00000100
#endif

/*!
 *  @}
 */


/*!
 *  \addtogroup proc    Processes
 *  @{
 */

typedef struct module_info_t module_info_t;
/*!
 *	\brief	User-mode module information structure
 *
 *	The kernel allocates one of these for each module (EXE or DLL) it loads 
 *		into a process. The \b process_info_t structure keeps a list of these.
 */
struct module_info_t
{
	/*! Pointer to the previous module in the process's list */
    module_info_t *prev;

	/*! Pointer to the next module in the process's list */
	module_info_t *next;

	/*! Full file name of the module*/
    wchar_t name[256];

	/*! Address of the module's image*/
    addr_t base;

	/*! Length of the module's image in memory*/
    size_t length;
};

typedef struct process_info_t process_info_t;
/*!
 *	\brief    User-mode process information structure
 *
 *	Each process has one of these, accessible using \b ProcGetProcessInfo()
 *		or the \b process field of the \b thread_info_t structure.
 *	This structure is also used when creating a new process.
 */
struct process_info_t
{
	/*! Unique process identifier */
    unsigned id;

	/*! Address of the process's executable image */
    addr_t base;

	/*! Handle to the process's standard input file */
    handle_t std_in;

	/*! Handle to the process's standard output file */
	handle_t std_out;

	/*! 
	 *	\brief	Current working directory
	 *
	 *	Change the current directory using \b FsChangeDir.
	 */
    wchar_t cwd[256];

	/*! Command line given when the process was started */
    wchar_t cmdline[256];

	/*! Pointer to the first module loaded */
    module_info_t *module_first;

	/*! Pointer to the last module loaded */
	module_info_t *module_last;

	/*!
	 *	\brief	Pointer to the function called as the entry point of new threads
	 *
	 *	\note	libsys sets the thread entry to an internal thread startup 
	 *		routine. It should not be necessary to change this. DLLs receive 
	 *		notification of thread creation and exit through their \b DllMain 
	 *		routines.
	 */
	void (*thread_entry)(void);
};

#define DLLMAIN_PROCESS_STARTUP	0
#define DLLMAIN_PROCESS_EXIT	1
#define DLLMAIN_THREAD_STARTUP	2
#define DLLMAIN_THREAD_EXIT		3

/*!
 *  @}
 */


/*!
 *  \addtogroup thr Threads
 *  @{
 */
#ifdef i386
typedef uint32_t FARPTR;

#define MK_FP(seg, off)    ((FARPTR) (((uint32_t) (seg) << 16) | (uint16_t) (off)))
#define FP_SEG(fp)        (((FARPTR) fp) >> 16)
#define FP_OFF(fp)        (((FARPTR) fp) & 0xffff)
#define FP_TO_LINEAR(seg, off) ((void*) ((((uint16_t) (seg)) << 4) + ((uint16_t) (off))))

#ifndef __CONTEXT_DEFINED
#define __CONTEXT_DEFINED
typedef struct pusha_t pusha_t;
struct pusha_t
{
    uint32_t edi, esi, ebp, esp, ebx, edx, ecx, eax;
};

/*! \brief The layout of the stack frame generated by the assembly-language 
 *    interrupt handler.
 *
 *    The isr_and_switch routine (in start.asm), along with the individual 
 *    interrupt handlers and the processor, build this structure on the stack
 *    before isr() is called.
 */
typedef struct context_t context_t;
struct context_t
{
    uint32_t kernel_esp;
    context_t *ctx_prev;
	uint32_t fault_addr;
    pusha_t regs;
    uint32_t gs, fs, es, ds;
    uint32_t intr, error;
    uint32_t eip, cs, eflags, esp, ss;
};

typedef struct context_v86_t context_v86_t;
struct context_v86_t
{
    uint32_t kernel_esp;
    context_t *ctx_prev;
	uint32_t fault_addr;
    pusha_t regs;
    uint32_t gs, fs, es, ds;
    uint32_t intr, error;
    uint32_t eip, cs, eflags, esp, ss;

    /* extra fields for V86 mode */
    uint32_t v86_es, v86_ds, v86_fs, v86_gs;
};
#endif

#endif


#ifdef exception_info
#undef exception_info
#endif


typedef struct thread_info_t thread_info_t;
/*!
 *	\brief	User-mode thead information structure
 *
 *	You can obtain a \b thread_info_t for the current thread by calling
 *	 \b ThrGetThreadInfo. On the x86 the \b FS segment contains this structure.
 */
struct thread_info_t
{
    /*!
     *  \brief DS-relative pointer to this structure
     *
     *  Use this pointer to avoid FS-relative memory accesses
     */
    thread_info_t *info;

    /*! Unique thread identitier */
    uint32_t id;

    /*! Pointer to this process's information structure */
    process_info_t *process;

    /*! Result code from the last syscall */
    int status;

    /*! Parameter passed to \b ThrCreateThread */
    void *param;

    /*! Pointer to the function called for each unhandled exception */
    void (*exception_handler)(void);

    /*! Pointer to the entry point function passed to \b ThrCreateThread */
    int (*entry)(void*);

    /*! Copy of the thread's context at the time of the last exception */
    context_t exception_info;

    /*! Pointer to the window manager's per-thread data structure */
    void *wmgr_info;

    /*!
     *  \brief Handles to events used for synchronous I/O, such as \b FsRead 
     *  or \b FsWrite
     */
    handle_t sync_io_events[2];

    unsigned next_sync_io_event;
};
/*!
 *  @}
 */

/*!
 *  \addtogroup fs  Files
 *  @{
 */

/*!    \brief   Path to the system boot directory (ramdisk) */
#define SYS_BOOT    L"/System/Boot"
/*!    \brief   Path to the system ports directory */
#define SYS_PORTS    L"/System/Ports"
/*!    \brief   Path to the system devices directory */
#define SYS_DEVICES    L"/System/Devices"

/*!    \brief    Maximum length of a path specification, in characters */
#ifndef WIN32
#define MAX_PATH    256
#endif

/* Flags for FsCreate() and FsOpen() */
/*!     \brief  Allows a file to be read from */
#define FILE_READ               0x01
/*!     \brief  Allows a file to be written to */
#define FILE_WRITE              0x02
#define FILE_FORCE_CREATE       0x04
#define FILE_FORCE_OPEN         0x08
#define FILE_CREATE_OPEN        (FILE_FORCE_CREATE | FILE_FORCE_OPEN)
#define FILE_IS_DIRECTORY       0x10

typedef struct fileop_t fileop_t;
/*!
 *    \brief    Contains status information for user-mode asynchronous I/O 
 *    operations
 */
struct fileop_t
{
    /*!
     *    \brief    Result of the operation
     *    Only valid just after calling \b FsReadAsync or \b FsWriteAsync and after
     *    having called \b ThrWaitHandle.
     *
     *    Valid error codes are found in errno.h.
     */
    status_t result;

    /*! Handle of the event to be signalled upon I/O completion */
    handle_t event;

    /*! Number of bytes transferred during the operation */
    size_t bytes;
};

#define FILE_ATTR_READ_ONLY     0x01
#define FILE_ATTR_HIDDEN        0x02
#define FILE_ATTR_SYSTEM        0x04
#define FILE_ATTR_VOLUME_ID     0x08
#define FILE_ATTR_DIRECTORY     0x10
#define FILE_ATTR_ARCHIVE       0x20
#define FILE_ATTR_DEVICE        0x1000
#define FILE_ATTR_LINK          0x2000

/* Flags for FsQueryFile() */
/*! \brief  Tests for the file's presence; does not return any other information */
#define FILE_QUERY_NONE         0
#define FILE_QUERY_DIRENT       1
/*! \brief  Returns \b dirent_standard_t information for the file */
#define FILE_QUERY_STANDARD     2
/*! \brief  Returns \b dirent_device_t information for the device */
#define FILE_QUERY_DEVICE       3

typedef struct dirent_t dirent_t;
/*! \brief    Contains information on an entry in a directory */
struct dirent_t
{
    unsigned vnode;
    wchar_t name[256];
};

typedef struct dirent_standard_t dirent_standard_t;
struct dirent_standard_t
{
    uint64_t length;
    uint64_t attributes;
    wchar_t mimetype[64];
};

typedef struct dirent_device_t dirent_device_t;
struct dirent_device_t
{
    wchar_t description[256];
    uint32_t device_class;
};

/*!
 *  @}
 */

#ifndef _WINUSER_
/*!
 *  \addtogroup res Resources
 *  @{
 */
#define RT_CURSOR           1
#define RT_BITMAP           2
#define RT_ICON             3
#define RT_MENU             4
#define RT_DIALOG           5
#define RT_STRING           6
#define RT_FONTDIR          7
#define RT_FONT             8
#define RT_ACCELERATOR      9
#define RT_RCDATA           10
#define RT_MESSAGETABLE     11
/*!
 *  @}
 */
#endif

/*!
 *  \addtogroup ke  System information
 *  @{
 */
typedef struct sysinfo_t sysinfo_t;
/*! \brief    Information structure for \b SysGetInfo() */
struct sysinfo_t
{
	/*!	Size of one page on the target architecture */
    size_t page_size;

	/*! Total amount of RAM available to the OS, in pages */
    size_t pages_total;

	/*! Total amount of RAM free, in pages */
    size_t pages_free;

	/*! Total amount of RAM installed, in pages */
    size_t pages_physical;

	/*! Number of pages reserved for use by the kernel */
    size_t pages_kernel;
};

typedef struct systimes_t systimes_t;
/*! \brief    Information structure for \b SysGetTimes() */
struct systimes_t
{
    unsigned quantum;
    unsigned uptime;
    unsigned current_cputime;
};

/* \brief Flags for \b SysShutdown */

#define SHUTDOWN_HALT       0
#define SHUTDOWN_REBOOT     1
#define SHUTDOWN_POWEROFF   2
#define SHUTDOWN_FLUSH      3

/*!
 *  @}
 */

/*!
 *  \addtogroup hnd Handles
 *  @{
 */
/* Special handle values */
#define HANDLE_NULL         0
#define HANDLE_PROCESS      1

/* Lightweight mutex */
typedef struct lmutex_t lmutex_t;
struct lmutex_t
{
    unsigned locks;
    void *eip;
    unsigned owner;
	handle_t mutex;
};

/*!
 *  @}
 */

#endif

put tracemunge into maltrace.  (simple hash table is all that's needed)

why print no-ops? fix realloc traces to be more meaningful

does it help reduce fragmentation if we set rover to the pointer *after*
the current block if we allocate by chopping a piece off the current
block.  it should help rayan's problem, in that we'll only use the big
block if there is no appropriate small block, and we try to avoid
chopping blocks up further.  it's a variant on wilderness preservation.

hmm, should we search for a block no more than twice as big
as we are, rather than first fit.  we stash a pointer to the
best block found so far, but search on for a better fit.
in a pathological case, this would be a best fit.

improve locations of CHECKHEAP, esp. realloc.

study doug lea's ideas for bin (_malloc_rovers) organization;  the
logarithmic separation of bins, is the deferred consolidation a good
idea, how about checking the last freed blocks.

more complex organizations of the _malloc_rovers structure?  dynamically
split and create bins to keep number of elements in a bin down? (do this
only on failed searches or suchlike, to avoid messing with the
structure if it's working)

prealloc splay trees in groups

rather than use firstbin, link _malloc_rovers[i] to the first non-empty
bin.  simplifies malloc search loop.  may need a subsidiary structure to
tell us whether the bin is really empty, so we can do the right thing
when we link something into the bin, or unlink last element from the bin.
or if we're really clever, maybe we can get it to happen automatically?

separate flag for start and end tags?  use lower 2 bits -- one bit for
free/allocated, other for start/end?  (pity we can't use third bit to
indicate arena boundaries)

alloca-like allocation with malloc -- mark()/release() paradigm.  specify a
point where one starts a stack (stk_create), and stk_alloc from that.
stk_free releases the specified stack.  This speeds up frees, doesn't speed
up mallocs too much?  Time it in trace situations.

Make the document a manual page.  Terser, less cutesy.

mal_size() returns size of a malloc'ed block in bytes.

Adaptive sbrk size. Keep increasing it by DEF_SBRKUNITS, then if sbrk fails,
half the sbrkunits till we're smaller than the request (in which case it's
all over). Should reduce the number of calls to sbrk without increasing
wastage too much.

Check that totalavail works right for realloc. Should we scrap totalavail
and save a pointer to the max block, so that can both tell if we need to
sbrk without a search, as well as realize if the max block has shrunk.
Problem: how do we know if the max block shrank below the size of some other
block? Heuristic? Average block size?  Some adapting fraction of totalavail?
We sbrk if request is greater than (1+fraction)*totalavail/nfree is what
Korn and Vo suggest.  Assuming fraction is always 1/K, we get
(K+1)*totalavail/K/nfree.  We can double K everytime we fail a search. To
provide some negative feedback, we can change the 1 to M, and increment M
everytime we succeed in a search. Doesn't sound good. Need a better
heuristic.  Grump. Avoid this stuff for now.
totalavail should not include wilderness.  that way, if totalavail < what
we need and wilderness is > what we need, we just get it from wilderness.
[trashed totalavail -- we'll improve later]


Separate all system dependent stuff into a sysdep header where these things
can fight it out.

create stdlib.h and move std. decls there.  keep malloc.h as a value added
thing and declare new stuff there.  decide on malloc(0).
(malloc 0 should return 0 sized block by default, I think)

setopt Non-ansi should cause malloc(0), realloc(0, *) or realloc(*, 0)
to fail.

some way to report when the last free happened when you try to use a freed
pointer.  maintain a splay tree where you add ptrs when you free'em and
delete when you malloc them?

improve my trace driven simulation stuff in ../maltrace.

way to walk the heap.  if it is a macro, then verify and dumpheap could
use it too.  should probably switch to arena before all these changes.

interns.h from externs.h. Then we don't need aexterns.h.  
